<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StegoCrypt - Hide Messages in Images</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.2em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-bottom: 30px;
        }

        .section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .section:hover {
            border-color: #667eea;
            transform: translateY(-5px);
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
        }

        .encode-icon { background: #4CAF50; }
        .decode-icon { background: #FF9800; }

        .upload-area {
            border: 3px dashed #ddd;
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            background: #fafafa;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-area.dragover {
            border-color: #4CAF50;
            background: #f0fff0;
        }

        .file-input {
            display: none;
        }

        .upload-text {
            color: #666;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .upload-hint {
            color: #999;
            font-size: 0.9em;
        }

        .message-input {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1em;
            resize: vertical;
            font-family: inherit;
            transition: border-color 0.3s ease;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px 5px;
            min-width: 150px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .preview-area {
            margin-top: 20px;
        }

        .image-preview {
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            border: 2px solid #eee;
            display: none;
        }

        .result-area {
            grid-column: 1 / -1;
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            text-align: center;
        }

        .result-message {
            font-size: 1.2em;
            color: #333;
            margin: 20px 0;
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #4caf50;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            border: 2px solid #f44336;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            margin: 15px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s ease;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .container {
                padding: 20px;
            }
        }

        .demo-section {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 30px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .demo-title {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.5em;
            color: #333;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .feature-card:hover {
            transform: translateY(-3px);
        }

        .feature-icon {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        .feature-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .feature-desc {
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîí StegoCrypt</h1>
            <p>Hide secret messages within images using advanced steganography</p>
        </div>

        <div class="main-content">
            <!-- Encode Section -->
            <div class="section">
                <h2><span class="icon encode-icon">üîê</span> Encode Message</h2>
                
                <div class="upload-area" id="encodeUpload">
                    <input type="file" id="encodeFile" class="file-input" accept="image/*">
                    <div class="upload-text">üìÅ Click or drag to upload image</div>
                    <div class="upload-hint">Supports PNG, JPG, BMP formats</div>
                </div>
                
                <img id="encodePreview" class="image-preview" alt="Preview">
                
                <textarea 
                    id="messageInput" 
                    class="message-input" 
                    placeholder="Enter your secret message here... You can write multiple paragraphs, use line breaks, and include any text content. The system will automatically check if your message fits in the selected image."
                    maxlength="10000"
                    rows="6"
                ></textarea>
                
                <div style="margin: 10px 0; font-size: 0.9em; color: #666;">
                    <span id="charCount">0</span> characters | 
                    <span id="estimatedBits">0</span> bits needed |
                    <span id="capacityStatus">Upload image to check capacity</span>
                </div>
                
                <div style="margin-top: 15px;">
                    <button id="encodeBtn" class="btn" disabled>üîê Hide Message</button>
                    <button id="downloadBtn" class="btn" style="display: none;">üíæ Download</button>
                </div>
            </div>

            <!-- Decode Section -->
            <div class="section">
                <h2><span class="icon decode-icon">üîì</span> Decode Message</h2>
                
                <div class="upload-area" id="decodeUpload">
                    <input type="file" id="decodeFile" class="file-input" accept="image/*">
                    <div class="upload-text">üìÅ Upload encoded image</div>
                    <div class="upload-hint">Upload an image with hidden message</div>
                </div>
                
                <img id="decodePreview" class="image-preview" alt="Preview">
                
                <div style="margin-top: 20px;">
                    <button id="decodeBtn" class="btn" disabled>üîì Extract Message</button>
                </div>
                
                <div id="extractedMessage" style="margin-top: 20px; display: none;">
                    <strong>Hidden Message:</strong>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin-top: 10px; word-wrap: break-word;"></div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="result-area">
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                
                <div id="resultMessage" class="result-message"></div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div id="imageSize" class="stat-value">0</div>
                        <div class="stat-label">Image Size (KB)</div>
                    </div>
                    <div class="stat-card">
                        <div id="messageLength" class="stat-value">0</div>
                        <div class="stat-label">Message Length</div>
                    </div>
                    <div class="stat-card">
                        <div id="capacity" class="stat-value">0%</div>
                        <div class="stat-label">Capacity Used</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Demo Features Section -->
        <div class="demo-section">
            <h3 class="demo-title">üöÄ Features Showcase</h3>
            <div class="feature-grid">
                <div class="feature-card">
                    <div class="feature-icon">üé®</div>
                    <div class="feature-title">LSB Steganography</div>
                    <div class="feature-desc">Uses Least Significant Bit technique to hide data invisibly</div>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üîê</div>
                    <div class="feature-title">Secure Hiding</div>
                    <div class="feature-desc">Messages are embedded without visible image changes</div>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">‚ö°</div>
                    <div class="feature-title">Real-time Processing</div>
                    <div class="feature-desc">Instant encoding and decoding in your browser</div>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üìä</div>
                    <div class="feature-title">Analytics</div>
                    <div class="feature-desc">Shows capacity, efficiency, and processing stats</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let encodeCanvas, decodeCanvas;
        let encodeCtx, decodeCtx;
        let encodeImageData, decodeImageData;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeUploadAreas();
            initializeButtons();
            createCanvases();
        });

        function createCanvases() {
            encodeCanvas = document.createElement('canvas');
            decodeCanvas = document.createElement('canvas');
            encodeCtx = encodeCanvas.getContext('2d');
            decodeCtx = decodeCanvas.getContext('2d');
        }

        function initializeUploadAreas() {
            setupUploadArea('encodeUpload', 'encodeFile', handleEncodeImage);
            setupUploadArea('decodeUpload', 'decodeFile', handleDecodeImage);
        }

        function setupUploadArea(uploadId, fileId, handler) {
            const uploadArea = document.getElementById(uploadId);
            const fileInput = document.getElementById(fileId);

            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handler);

            // Drag and drop functionality
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    handler({ target: { files } });
                }
            });
        }

        function initializeButtons() {
            const encodeBtn = document.getElementById('encodeBtn');
            const decodeBtn = document.getElementById('decodeBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const messageInput = document.getElementById('messageInput');
            
            // Add click event listeners
            encodeBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Encode button clicked');
                encodeMessage();
            });
            
            decodeBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Decode button clicked');
                decodeMessage();
            });
            
            downloadBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Download button clicked');
                downloadEncodedImage();
            });
            
            messageInput.addEventListener('input', updateMessageStats);
            
            console.log('All event listeners initialized');
        }

        function handleEncodeImage(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        displayImage(img, 'encodePreview', encodeCanvas, encodeCtx);
                        document.getElementById('encodeBtn').disabled = false;
                        
                        const imagePixels = img.width * img.height;
                        const availableBits = imagePixels * 3; // RGB channels
                        const maxChars = Math.floor(availableBits / 8) - 20; // Reserve space for delimiter
                        
                        console.log(`üìä Image capacity: ${img.width}x${img.height} = ${imagePixels} pixels`);
                        console.log(`üìä Available bits: ${availableBits} (RGB channels)`);
                        console.log(`üìä Max characters: ~${maxChars}`);
                        
                        // Update the textarea max length based on image capacity
                        const messageInput = document.getElementById('messageInput');
                        if (maxChars < 10000) {
                            messageInput.setAttribute('maxlength', maxChars.toString());
                        }
                        
                        updateStats(file.size / 1024, 0, 0);
                        updateMessageStats(); // Refresh capacity status
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function handleDecodeImage(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        displayImage(img, 'decodePreview', decodeCanvas, decodeCtx);
                        
                        // Store the image data for decoding
                        decodeImageData = decodeCtx.getImageData(0, 0, decodeCanvas.width, decodeCanvas.height);
                        
                        // Enable the decode button
                        const decodeBtn = document.getElementById('decodeBtn');
                        decodeBtn.disabled = false;
                        decodeBtn.style.opacity = '1';
                        
                        console.log('Decode image loaded:', decodeCanvas.width, 'x', decodeCanvas.height);
                    };
                    img.crossOrigin = 'anonymous'; // Handle CORS issues
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function displayImage(img, previewId, canvas, ctx) {
            const preview = document.getElementById(previewId);
            preview.src = img.src;
            preview.style.display = 'block';

            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
        }

        function updateMessageStats() {
            const message = document.getElementById('messageInput').value;
            const messageLength = message.length;
            const estimatedBits = (messageLength + 10) * 8; // +10 for delimiter
            
            document.getElementById('charCount').textContent = messageLength;
            document.getElementById('estimatedBits').textContent = estimatedBits;
            
            // Check capacity if we have an image loaded
            if (encodeCanvas && encodeCanvas.width > 0) {
                const imagePixels = encodeCanvas.width * encodeCanvas.height;
                const availableBits = imagePixels * 3; // RGB channels
                const capacityPercent = Math.round((estimatedBits / availableBits) * 100);
                
                const capacityStatus = document.getElementById('capacityStatus');
                if (capacityPercent <= 50) {
                    capacityStatus.textContent = `‚úÖ ${capacityPercent}% capacity used - Excellent`;
                    capacityStatus.style.color = '#4CAF50';
                } else if (capacityPercent <= 80) {
                    capacityStatus.textContent = `‚ö†Ô∏è ${capacityPercent}% capacity used - Good`;
                    capacityStatus.style.color = '#FF9800';
                } else if (capacityPercent <= 100) {
                    capacityStatus.textContent = `üî• ${capacityPercent}% capacity used - Near limit`;
                    capacityStatus.style.color = '#FF5722';
                } else {
                    capacityStatus.textContent = `‚ùå ${capacityPercent}% - Message too long!`;
                    capacityStatus.style.color = '#F44336';
                }
            }
            
            updateStats(null, messageLength, null);
        }

        function updateStats(imageSize, messageLength, capacityUsed) {
            if (imageSize !== null) {
                document.getElementById('imageSize').textContent = Math.round(imageSize);
            }
            if (messageLength !== null) {
                document.getElementById('messageLength').textContent = messageLength;
            }
            if (capacityUsed !== null) {
                document.getElementById('capacity').textContent = capacityUsed + '%';
            }
        }

        // Improved binary conversion functions
        function stringToBinary(str) {
            let binary = '';
            for (let i = 0; i < str.length; i++) {
                const charCode = str.charCodeAt(i);
                const binaryChar = charCode.toString(2).padStart(8, '0');
                binary += binaryChar;
            }
            console.log(`String "${str}" converted to binary: ${binary.substring(0, 50)}... (${binary.length} bits)`);
            return binary;
        }

        function binaryToString(binary) {
            try {
                // Clean the binary string - remove non-binary characters
                const cleanBinary = binary.replace(/[^01]/g, '');
                
                // Make sure we have complete bytes
                const completeBytes = cleanBinary.substring(0, Math.floor(cleanBinary.length / 8) * 8);
                
                if (completeBytes.length === 0) return '';
                
                let result = '';
                let byteCount = 0;
                
                for (let i = 0; i < completeBytes.length; i += 8) {
                    const byte = completeBytes.substring(i, i + 8);
                    const charCode = parseInt(byte, 2);
                    byteCount++;
                    
                    // Debug first and last few bytes
                    if (byteCount <= 5 || byteCount >= Math.floor(completeBytes.length / 8) - 5) {
                        console.log(`Byte ${byteCount}: ${byte} -> charCode: ${charCode} -> char: "${String.fromCharCode(charCode)}"`);
                    }
                    
                    // Handle ALL valid text characters including newlines and paragraphs
                    if (charCode >= 32 && charCode <= 126) {
                        // Printable ASCII characters (space, punctuation, letters, numbers, symbols)
                        result += String.fromCharCode(charCode);
                    } else if (charCode === 10) { // Line Feed (LF) - \n
                        result += '\n';
                    } else if (charCode === 13) { // Carriage Return (CR) - \r
                        result += '\r';
                    } else if (charCode === 9) { // Tab character
                        result += '\t';
                    } else if (charCode === 0) {
                        // Null character - likely end of data
                        console.log('Found null character at byte', byteCount, '- stopping conversion');
                        break;
                    } else {
                        // Log but skip other control characters (1-31, 127-255)
                        if (byteCount <= 20) { // Only log first 20 to avoid spam
                            console.log(`Skipping control/extended character: ${charCode} at byte ${byteCount}`);
                        }
                    }
                }
                
                console.log(`‚úÖ Binary converted to string: "${result}" (${result.length} characters from ${byteCount} bytes)`);
                return result;
                
            } catch (error) {
                console.error('‚ùå Error converting binary to string:', error);
                return '';
            }
        }

        function encodeMessage() {
            const message = document.getElementById('messageInput').value;
            if (!message || message.trim().length === 0) {
                showResult('Please enter a message to hide!', 'error');
                return;
            }

            console.log('=== PARAGRAPH ENCODING STARTED ===');
            console.log(`üìù Original message (${message.length} chars):`);
            console.log(`"${message}"`);
            
            // Show line breaks and special characters
            const lines = message.split('\n');
            console.log(`üìÑ Message contains ${lines.length} line(s):`);
            lines.forEach((line, index) => {
                console.log(`Line ${index + 1}: "${line}"`);
            });
            
            showProgress(true);
            
            setTimeout(() => {
                try {
                    // Add delimiter to mark end of message  
                    const fullMessage = message + '|||END|||';
                    console.log(`üìù Full message with delimiter (${fullMessage.length} chars)`);
                    
                    const binaryMessage = stringToBinary(fullMessage);
                    console.log(`üî¢ Binary length: ${binaryMessage.length} bits`);
                    
                    encodeImageData = encodeCtx.getImageData(0, 0, encodeCanvas.width, encodeCanvas.height);
                    const data = encodeImageData.data;
                    
                    // Check capacity
                    const availablePixels = Math.floor(data.length / 4);
                    const availableBits = availablePixels * 3; // RGB channels only
                    const requiredBits = binaryMessage.length;
                    const capacityPercent = Math.round((requiredBits / availableBits) * 100);
                    
                    console.log(`üñºÔ∏è  Image: ${encodeCanvas.width}x${encodeCanvas.height} (${availablePixels} pixels)`);
                    console.log(`üíæ Available bits: ${availableBits}`);
                    console.log(`üìä Required bits: ${requiredBits}`);
                    console.log(`üìà Capacity used: ${capacityPercent}%`);
                    
                    if (requiredBits > availableBits) {
                        const maxChars = Math.floor(availableBits / 8) - 20;
                        showResult(`‚ùå Message too long! Maximum ${maxChars} characters for this image.`, 'error');
                        showProgress(false);
                        return;
                    }

                    // Encode message using LSB - handle large messages efficiently
                    let messageIndex = 0;
                    let pixelCount = 0;
                    
                    console.log('üîÑ Starting bit-by-bit encoding...');
                    
                    for (let i = 0; i < data.length && messageIndex < binaryMessage.length; i += 4) {
                        pixelCount++;
                        
                        // Process RGB channels (skip alpha channel at i+3)
                        for (let j = 0; j < 3 && messageIndex < binaryMessage.length; j++) {
                            const originalValue = data[i + j];
                            const bit = parseInt(binaryMessage[messageIndex]);
                            
                            // Clear LSB and set new bit
                            data[i + j] = (originalValue & 0xFE) | bit;
                            messageIndex++;
                            
                            // Update progress more frequently for large messages
                            if (messageIndex % 500 === 0 || messageIndex === binaryMessage.length) {
                                updateProgress((messageIndex / binaryMessage.length) * 100);
                            }
                        }
                        
                        // Log progress for very large messages
                        if (pixelCount % 10000 === 0) {
                            console.log(`üîÑ Processed ${pixelCount} pixels, encoded ${messageIndex}/${binaryMessage.length} bits`);
                        }
                    }

                    console.log(`‚úÖ Encoding completed successfully!`);
                    console.log(`üìä Total bits encoded: ${messageIndex}/${binaryMessage.length}`);
                    
                    if (messageIndex !== binaryMessage.length) {
                        console.warn('‚ö†Ô∏è Warning: Not all bits were encoded!');
                    }
                    
                    encodeCtx.putImageData(encodeImageData, 0, 0);
                    
                    // Update the preview image
                    const encodedDataURL = encodeCanvas.toDataURL('image/png');
                    document.getElementById('encodePreview').src = encodedDataURL;
                    
                    document.getElementById('downloadBtn').style.display = 'inline-block';
                    
                    updateStats(null, null, capacityPercent);
                    
                    showResult(`‚úÖ ${message.length} character message successfully hidden! (${capacityPercent}% capacity used)`, 'success');
                    showProgress(false);
                    
                } catch (error) {
                    console.error('‚ùå Encoding error:', error);
                    showResult('Error encoding message: ' + error.message, 'error');
                    showProgress(false);
                }
            }, 100);
        }

        function decodeMessage() {
            console.log('=== DECODE PROCESS STARTED ===');
            
            const decodeBtn = document.getElementById('decodeBtn');
            decodeBtn.disabled = true;
            decodeBtn.textContent = 'üîÑ Extracting...';
            
            showProgress(true);
            
            setTimeout(() => {
                try {
                    // Make sure we have image data
                    if (!decodeImageData) {
                        decodeImageData = decodeCtx.getImageData(0, 0, decodeCanvas.width, decodeCanvas.height);
                    }
                    
                    const data = decodeImageData.data;
                    console.log('Decode image dimensions:', decodeCanvas.width, 'x', decodeCanvas.height);
                    console.log('Image data length:', data.length);
                    
                    let binaryMessage = '';
                    const delimiter = stringToBinary('|||END|||');
                    console.log('Delimiter in binary:', delimiter);
                    
                    let foundDelimiter = false;
                    let pixelCount = 0;
                    
                    // Extract bits from LSB of RGB channels - same order as encoding
                    for (let i = 0; i < data.length && !foundDelimiter; i += 4) {
                        pixelCount++;
                        
                        // Process RGB channels in same order as encoding
                        for (let j = 0; j < 3 && !foundDelimiter; j++) {
                            // Get the least significant bit
                            const bit = (data[i + j] & 1);
                            binaryMessage += bit.toString();
                            
                            // Debug first few decodings
                            if (binaryMessage.length <= 20) {
                                console.log(`Bit ${binaryMessage.length}: Pixel ${pixelCount}, Channel ${j}, Value=${data[i + j]}, LSB=${bit}`);
                            }
                            
                            // Check for delimiter more frequently for better detection
                            if (binaryMessage.length >= delimiter.length) {
                                const lastBits = binaryMessage.slice(-delimiter.length);
                                if (lastBits === delimiter) {
                                    foundDelimiter = true;
                                    console.log('‚úì DELIMITER FOUND at bit position:', binaryMessage.length - delimiter.length);
                                    break;
                                }
                            }
                            
                            // Update progress
                            if (binaryMessage.length % 1000 === 0) {
                                updateProgress(Math.min((binaryMessage.length / (data.length * 0.75)) * 100, 95));
                            }
                            
                            // Reasonable safety limit
                            if (binaryMessage.length > 100000) {
                                console.log('Reached safety limit of 100000 bits');
                                break;
                            }
                        }
                    }
                    
                    console.log('Total bits extracted:', binaryMessage.length);
                    console.log('First 100 bits:', binaryMessage.substring(0, 100));
                    console.log('Last 100 bits:', binaryMessage.slice(-100));
                    
                    if (foundDelimiter) {
                        // Remove delimiter
                        const messageBinary = binaryMessage.slice(0, -delimiter.length);
                        console.log('Message binary (without delimiter):', messageBinary.length, 'bits');
                        console.log('Message binary content:', messageBinary);
                        
                        // Convert to string
                        const decodedMessage = binaryToString(messageBinary);
                        console.log('Final decoded message:', `"${decodedMessage}"`);
                        
                        if (decodedMessage && decodedMessage.trim().length > 0) {
                            displayExtractedMessage(decodedMessage);
                            showResult('‚úÖ Message successfully extracted!', 'success');
                        } else {
                            // Show the binary data for debugging
                            console.log('Decoded message is empty, showing binary data for debug');
                            displayExtractedMessage(`[Binary data: ${messageBinary.substring(0, 200)}...]`);
                            showResult('‚ö†Ô∏è Message extracted but appears empty or corrupted.', 'error');
                        }
                    } else {
                        // Delimiter not found - let's try to decode without it
                        console.log('‚ùå Delimiter not found, trying to decode first part of data...');
                        
                        // Try decoding first 1000 bits to see if there's readable text
                        const testBinary = binaryMessage.substring(0, Math.min(1000, binaryMessage.length));
                        const testMessage = binaryToString(testBinary);
                        
                        console.log('Test decode (first 1000 bits):', `"${testMessage}"`);
                        
                        if (testMessage && testMessage.trim().length > 0) {
                            displayExtractedMessage(`Partial: ${testMessage}`);
                            showResult('‚ö†Ô∏è Partial message found (delimiter missing). Message may be incomplete.', 'success');
                        } else {
                            showResult('‚ùå No readable message found. This image may not contain encoded data.', 'error');
                        }
                    }
                    
                    showProgress(false);
                    
                } catch (error) {
                    console.error('Decode error:', error);
                    showResult('Error decoding message: ' + error.message, 'error');
                    showProgress(false);
                } finally {
                    // Reset button
                    decodeBtn.disabled = false;
                    decodeBtn.textContent = 'üîì Extract Message';
                }
            }, 100);
        }

        function displayExtractedMessage(message) {
            const messageDiv = document.getElementById('extractedMessage');
            const contentDiv = messageDiv.querySelector('div');
            
            // Clean up the message and display it properly
            const cleanMessage = message.replace(/\0/g, '').trim(); // Remove null characters
            contentDiv.textContent = cleanMessage || '[Message appears to be empty or corrupted]';
            contentDiv.style.fontFamily = 'monospace';
            contentDiv.style.fontSize = '1.1em';
            contentDiv.style.lineHeight = '1.4';
            messageDiv.style.display = 'block';
            
            // Also log to console for debugging
            console.log('Extracted message:', cleanMessage);
            console.log('Message length:', cleanMessage.length);
        }

        function downloadEncodedImage() {
            try {
                // Create download link
                const link = document.createElement('a');
                link.download = 'stegocrypt_encoded.png';
                
                // Convert canvas to blob for better compatibility
                encodeCanvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    link.href = url;
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Clean up
                    URL.revokeObjectURL(url);
                    
                    showResult('üì• Image downloaded successfully!', 'success');
                }, 'image/png', 1.0);
                
            } catch (error) {
                console.error('Download error:', error);
                // Fallback method
                try {
                    const link = document.createElement('a');
                    link.download = 'stegocrypt_encoded.png';
                    link.href = encodeCanvas.toDataURL('image/png');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showResult('üì• Image downloaded!', 'success');
                } catch (fallbackError) {
                    showResult('‚ùå Download failed. Right-click the preview image and save manually.', 'error');
                }
            }
        }

        function showProgress(show) {
            const progressBar = document.getElementById('progressBar');
            progressBar.style.display = show ? 'block' : 'none';
            if (!show) {
                updateProgress(0);
            }
        }

        function updateProgress(percentage) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = percentage + '%';
        }

        function showResult(message, type) {
            const resultDiv = document.getElementById('resultMessage');
            resultDiv.textContent = message;
            resultDiv.className = `result-message ${type}`;
            resultDiv.style.display = 'block';
            
            setTimeout(() => {
                resultDiv.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html>